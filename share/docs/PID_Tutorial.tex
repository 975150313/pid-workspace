\documentclass[12pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{upquote}

\begin{document}
\title{%
    \begin{minipage}\linewidth
        \centering\bfseries\sffamily
        PID : Packaging - Integration - Development 
        \vskip3pt
        \large An integrated software development process
        	\vskip3pt
        	\large Tutorial Document
    \end{minipage}
}

\author{
	Robin Passama\\
	CNRS Research Engineer\\
	Robotic Department\\	
	LIRMM - UMR5506 - University Of Montpellier\\	
	\texttt{passama@lirmm.fr}}
\date{October 2013}

\maketitle

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip

\begin{figure}
\center
\includegraphics[scale=0.7]{images/logos_officiels.png}
\end{figure}

\pagebreak

\part*{Introduction}
The main goal of this document is to provide a method that helps improving the overall quality of the code and applications produced by the robotics department of LIRMM. By improving the quality we aim at:
\begin{itemize}
\item simplifying the understanding and the modification of code produced by others.
\item simplifying the reuse of software components we develop.
\item pooling software developments between robotic teams.
\end{itemize}

To achieve this goal the Finding, Writing, Compiling, Testing, Version controlling and Documenting of the code are mandatory concerns. This document define in part 1, how the whole development process is organized, which tools are used and which concepts are handled. Then part 2 provides tutorials on many aspects, as well repository management as package definition.

\pagebreak

\part{Basic Concepts}

The following subsections explain basic concepts that need to be understood to start working with the PID methodology. First of all, root concepts are:

\begin{itemize}

\item \textbf{package} : a package is the basic unit for code development, unit testing, source version controlling, deployment specification, documentation writing. A package provides some functional code that can be reused (libraries, executables, header files, scripts, etc.) and depends on other packages either for its compilation (static libraries, header files archives/folders) or for its runtime use (dynamic libraries, executables, script-like files). It can contains as well an entire huge software (e.g. operating system) as a very elementary piece of code (e.g. header files, a library, etc.).A package has two main different forms :
\begin{itemize}
\item a source form. In this form, the package is a git repository that contains the  package's source code. It is something "alive" that is continuously evolving along development process.
\item a binary form. In this form, the package is a collection of software artefacts (headers, configuration files, executables, libraries, documentation, etc.) deployed in a given place of a file system. It is something static (does not evolved) that is associated to a specific version of the package's source form. A binary package can be embedded into an archive in order to be easily retrieved and deployed on a file system.
\end{itemize}

\item \textbf{workspace}:  the workspace is the folder hierarchy in which the user develops source packages and deploys the binary packages he uses (third party or resulting from its own package deployment). The basic idea is to avoid to use system dependencies : every software artefact in the development process is then local and relative to the workspace, except of course artefacts bound to system dependencies. 

\item \textbf{package server} : a package server is a computer (accessible across the network) that hosts many packages (either source or binary). It centralizes the access to packages, and handles the rights of the users for each package. It is responsible of the global version control of packages. It can also provides tools to manage the development of packages it hosts (teams members, bugs and activities tracking/reports, wiki, version history and development branches, visualization, etc.).
\end{itemize}
 
The present document helps normalizing the development of packages inside workspace, and the way packages and workspaces are managed on development servers. As definition of concept and process is intrinsically bound to the concepts and process involved in the software tools used, the section first quickly present these tools. Then we define core concepts of the PID methodology based on those of the tools.
 
\section{Tooling}

For each development task in a package, a tool is used to achieve this task. To ease the portability of code, only \textbf{cross platforms} tools are used:
\begin{itemize}
\item \textbf{git} is used for the concurrent version control and patching of the code. It is also the tool used to deliver and retrieve the source code.
\item \textbf{cmake} is used to manage the build process, but also deployment and test.
\item \textbf{doxygen} is used to generate api documentation of source code.
\item \textbf{latex} is the preferred language to write documents, since it allows to version the full content of file (raw text and structure of the document), as opposed to binary formats like Microsoft Word or Libre-Office that are not well handled by git.
\end{itemize}

Other tools used, like the compiler/linker (e.g. gcc) used with cmake, or the ssh agent used with git, or even development environment (e.g. Xcode, Eclipse) interfaced with cmake, git and doxygen, are supposed to be native (i.e. specific to the OS used) and so adapted by the user depending on the platform he uses and his own preferences.

\section{Package}
\label{sec:Package}

The package is the basic working unit for developers. A package :
\begin{itemize}
\item contains the functional source code.
\item contains the tests source code.
\item contains version control information files.
\item contains the compilation files used to : build the source code and documentation, run tests, generate configuration files, install its resulting binary form in the workspace and generate an installable archive of its binary form.
\end{itemize}

The main idea is that a package is self-explanatory. It does not means it contains all code and artefacts it uses but it contains all information needed to satisfy its dependencies. In other words considering a given package, its installation process is done using this information and the information contained in its dependent packages.

One important concept when dealing with PID packages is the concept of \textbf{component} : it is a software artefact produced  by a package. It may be either:
\begin{itemize}
\item a \textbf{library} : this is a component that can be reused by developers to build other components. We define three types of libraries : \textbf{shared} (runtime or load-time linked library), \textbf{static} (link time only linked library) and \textbf{header} (compile time only "linked" library).
\item an \textbf{application} : this is a component for end-users or developers that define a runtime behaviour. We define three types of applications : application (made for end-user or developers when it is a runtime component), example (demonstrating how to use libraries) and test (used only internally to a package to test its other components).
\end{itemize}

\pagebreak

\subsection{Package Structure}
\label{sec:PackageStruct}

A Package is generically structured according to the folder hierarchy defined below:
\begin{itemize}
\item the root folder of the package has the \textbf{name of the package}. This folder is basically a git repository which allows to manage concurrent work and version control on a package's content.
\item the \textbf{.git} folder contains version control related information, automatically managed by the git tool.
\item the root \textbf{.gitignore} file is used to exclude from version control some artefacts like temporary files.
\item the \textbf{CMakeList.txt} file is used to describe how to build, install and test the whole package. It also contains meta-information on the package (authors and institutions, repository address, license, etc.).
\item the \textbf{build} folder contains results from build process and contains two subdirectories: \textbf{release} and \textbf{debug}. Each of them contains the hierarchy of files and artefacts generated by the compilation process.
\item the \textbf{src} folder contains sources files (.c/.cpp/.cc in C/C++) of libraries. Each subdirectory of \textbf{src} contains sources use to build one or more library and is itself hierarchically organized according to developers needs. Libraries provided by the package are defined by the CMakeList.txt file contained in the \textbf{src} folder.
\item the \textbf{include} folder contains interface description files, typically exported (i.e. installed) headers files (.h, .hpp, .hh) in C/C++. Hierarchical organization in this directory is the same as in \textbf{src}. Non exported headers are let in the \textbf{src} folder, as they are not considered as a part of the interface of the package.
\item the \textbf{apps} folder contains source files for applications, an application being an example of the usage of a library, a runtime component or a end-user software. Each subdirectory of \textbf{apps} contains sources for one or more built application and is hierarchically organized according to developers needs. Applications provided by the package are defined by the CMakeList.txt file contained in the \textbf{apps} folder.
\item the \textbf{test} folder contains source files for test units. Each subdirectory of \textbf{test} contains sources for one or more test unit. Custom test programs and running tests applied to the package are defined by the CMakeList.txt file contained in the \textbf{test} folder.
\item the \textbf{share} folder contains user written documents and some specific files used by the build process. Its contains different basic subdirectories :
\begin{itemize}
\item the \textbf{doxygen} folder contains a "default" Doxyfile.in file that is used by doxygen to generate API documentation. This file can be modified by the user to add additional information to the generated documentation. The folder can also contain additional resources (like images), hierarchically organized according to developers needs, used by doxygen to integrate additionnal information in the API documentation.
\item the \textbf{cmake} folder contains cmake scripts (notably find scripts) that the package uses to find external resources like libraries. This is the place used only for very specific resources for which no default cmake script is available.
\item the \textbf{config} folder contains configurations files used by libraries and applications/tests of the package.
\item the \textbf{doc} folder contains "hand-written" documents (e.g. README files, tutorials, design documents, etc.).
\end{itemize}
The \textbf{share} folder define a CMakeList.txt file that can be used to install resources of the \textbf{doc} and \textbf{config} folders.
\item the \textbf{license.txt} file contains the license that applies to the source code produced in the package. This file is generated by the build process.
\end{itemize}

\pagebreak

\subsection{Package repository}

Package repositories are GIT repositories, whose content is structured according to the previously defined pattern. GIT is used to version all text files used (C/C++ sources, cmake scripts, latex sources, etc.). Only source form of a package is a git repository not its binary forms.

\subsubsection{Version Numbers as GIT Tags}
\label{sec:versiontags}

A package is continuously evolving along time and git provide an internal version representation of this evolution. Nevertheless, this representation is so fine grained (each time a modification is committed) that it is not really understandable by persons not involved in the package development. That is why we need a version representation that can be either understandable by users and developers. These versions, called \textbf{release version} are defined according to a specific policy.

A \textbf{release version} can be viewed as a screen-shot of the git repository at a given time of package's life. It is associated to a number (called \textbf{release version number}) that is uniquely identifying the version. Technically, a version if represented as a \textbf{GIT tag} : a git tag memorizes a given state of the repository and is marked with a unique label that is used to retrieve this state. In our context the label of the git tag represents the release version number and the repository state pointed by the tag corresponds to the release version. The labelling of git tags representing release versions follows the pattern bellow:
\begin{itemize}
\item the release tags have the shape \texttt{vX.Y[.Z]}
\item \texttt{X} is the major version number (starts with value 0). Change of major version number indicates that the code is no more completely backward compatible with previous versions. In other words, the interface of the package (some of the headers files it contains) has been modify in such a way that some function have change or disappeared, or the behaviour/meaning of existing functions completely changed. While X is 0 the version is considered as pre-released and so is not ready for use by third party developers.
\item \texttt{Y} is the minor version number (starts with value 0). It indicates an improvement that is completely backward compatible with previous version with same major version number. In other words, the only a little change of existing behaviours occurred OR the interface of the package has been improved with new functionalities without breaking the way one use the older functionalities.
\item \texttt{Z} is the patch version (starts with value 0). It represents a simple bug fix or a security fix. A patch changes nothing to the interface (no new behaviour/functionality) and modify only in a minimal way the internal behaviour.
\end{itemize}

Each time a new version of a package is released, its version number must be incremented according to the previously defined rules and a corresponding git tag is created. Here are some examples:
\begin{itemize}
\item 0.1.0 is the first pre-released version of the package.
\item 0.Y.Z. are early development pre-released version of the package.
\item 1.0.0 is the first release of source code.
\item 1.2.0  is a release of source code backward compatible with version 1.0.0.
\item 1.2.5 is a release of source code of version 1.2.0 with 5 bug/security fixes.
\item 2.0.0 is a release that is no more backward compatible with 1.X.Y versions.
\end{itemize}

\subsubsection{Development process with GIT branches}

GIT branches are used to organize the development workflow by registering "increments" made in the repository. Increments are modifications of the repository content, either source code, documentation, etc. A git repository can have many branches representing parallel development work. Most of time developers create branches to isolate the work they do on a specific concern as regard of the software development. This work is keep isolated from the work made on other concerns until developers think this is the good time to integrate (or discard) them. From time to time GIT branches are created, deleted, and merged. Merging consists in registering modifications made in two or more branches into a single branch.

As GIT branches can be used to represent any type of concern their understanding can quickly become a real problem. That is why their usage is constrained according to a predefined pattern inspired from successful branching models. This pattern defines what is the meaning of branches, what they are use for and the way they are created and merged :

\textbf{Main branches} (see in figure~\ref{fig-perm-branches}) have infinite lifetime and must always be usable : their last commit must point to a state in which the package is compilable and executable with unit tests successful.
\begin{itemize}
\item The \textbf{master} branch contains the source code that always reflects a production-ready state. This branch is used to \textbf{tag} the released stable source code with version numbers but also to tag important intermediate states of the repository that reflect the development made for demonstrations and publications. 
\item The \textbf{integration} branch contains the detailed history of all the modification that have been realized on the repository. The source code of HEAD (pointer on the current state of the repository) always reflects a state with the latest delivered development changes for the next release. This is where any automatic nightly builds are built from, if any.
\item When the source code in the \textbf{integration} branch reaches a stable point and is ready to be released, all of the changes should be merged back into \textbf{master} somehow and then tagged with an adequate release number.
\end{itemize}


\begin{figure}
\center
\includegraphics[scale=1]{images/permanent_branches.png}
\caption{Permanent branches of a package}
\label{fig-perm-branches}
\end{figure}

\begin{figure}
\center
\includegraphics[scale=1]{images/feature_branching.png}
\caption{Relation between feature and integration branches}
\label{fig-feature-branches}
\end{figure}

\textbf{Supporting branches} are temporary branches, used to aid parallel development between team members, ease tracking of features and to assist in quickly fixing live production problems.
\begin{itemize}
\item \textbf{Features} branches (see figure ~\ref{fig-feature-branches}) are used to develop new features /address new topics for the upcoming or a distant future release. Each feature branch must branch from the \textbf{integration} branch. A feature branch exists as long as the feature is in development, but will be merged back into develop (to definitely add the new feature to the upcoming release) or discarded (in case of a disappointing experiment). During its lifetime a feature should be updated from time to time with the modifications contained in the \textbf{integration} branch (issued for instance from the integration of other features). Doing so, the final merge of the feature will be more easy as the state of the feature will be not to far, in terms of importance of modifications, from the state of the \textbf{integration} branch.
\item \textbf{Hotfixes} branches (see figure ~\ref{fig-hotfix-branches}) arise from the necessity to act immediately upon an undesired state of a released version. When a critical bug in a realease version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the \textbf{master} branch that marks the production version. Hotfix branches are used to allow team members to continue their work (on the \textbf{integration} and \textbf{feature} branches), while another person is preparing a quick bug/security fix. When bugs are solved, the bug fix must be merged back into both \textbf{master} and \textbf{integration} branches. When merged the \textbf{master} branch is tagged with a new \textit{patch version number}.
\end{itemize}

\begin{figure}
\center
\includegraphics[scale=1]{images/hotfix_branching.png}
\caption{Relation between hotfix and integration/master branches}
\label{fig-hotfix-branches}
\end{figure}

\textbf{Naming Conventions:}
\begin{itemize}
\item a \textbf{feature} branch name starts with "feature-" and ends with the name of the feature (given by developer).
\linebreak example : \texttt{feature-newfunctionnality}
\item a \textbf{hotfix} branch name starts with "hotfix-" and ends with the new \textit{patch version} of the released version.
\linebreak example : \texttt{hotfix-1.2.1}
\end{itemize}

\subsubsection{Collaborative working with GIT repositories}
\label{sec:gitrepositories}

Now that the way the package is structured and is evolving the last part of this section consist in defining how people involved in the package's life cycle work together. The first concern is to define the \textbf{privileges} owned by these persons as regard of the repository usage. To do so we first define the three roles associated to each package:
\begin{itemize}
\item \textbf{users} are people using the package but not involved in its development.
\item \textbf{developers} are users involved in the development of a package.
\item \textbf{administrators} are developers with additional privileges, as they are considered as responsible of the package by users of the package.
\end{itemize}

Privileges associated to each role are managed inside the \textbf{package server} that hosts the package: 
\begin{itemize}
\item each package repository is associated to three \textit{groups}, each one representing a role previously defined. For example, for a package "a-pack" , there are groups "a-pack-users", "a-pack-developers" and "a-pack-administrators". Each group provides specific privileges on the package repository.
\item users registered inside the \textbf{package server} may be affected to one of these \textit{groups}. Doing so, these users obtain corresponding privileges on the package repository.
\item the repository can be set "public" so that anyone is considered as a user. In this case the users group may be not useful and can be let undefined.
\end{itemize}

\begin{figure}
\center
\includegraphics[scale=1]{images/collaborativework.png}
\caption{Collaboration between developers and repository}
\label{fig-collab}
\end{figure}

The basic scheme for collaborative working between package developers is presented in figure~\ref{fig-collab}. 
Given a package, this package has an \textbf{official GIT repository} that is deployed on a given \textbf{package server}. This repository is \textit{official} because it centralizes information of the package and is public, which means that all concerned people (team, laboratory or more generally anyone registered in the server) can access to it. The access in itself is restricted with respects to roles:
\begin{itemize}
\item registered \textbf{administrators} have read/write access on the official package.
\item all other registered \textbf{users} have read access.
\item unregistered people may have read access (i.e. open source repository).
\end{itemize}

During development, one or more \textbf{private repositories} of the package can be created by \textit{forking} the official repository. Depending on the official repository either only registered administrators (private package), developers (protected package), users (public package), or anyone (open package) can \textit{fork} the official repository. Then the creator in addition of the administrators of the official, become \textbf{administrators} of the private repository. Then they can register new \textbf{users} and \textbf{developers} for this repository, with following privileges:
\begin{itemize}
\item registered \textbf{administrators} and \textbf{developers} have read/write access.
\item registered \textbf{users} have read access.
\item unregistered people have no access.
\end{itemize}

These repositories help structuring the development process by grouping developers work around a common repository while not immediately impacting the official one. This lets the time to the \textbf{administrators} to check if everything is OK and that modifications can be merged back into the official repository. The main purpose when using \textbf{private repositories}, is to separate the work on the same package made by different groups. For instance, a PhD student working on its demos on one side and a team with external people working in a common research project on the other side.

Administrators of the official package are the only ones that can update the \textbf{official repository} with modifications made on private repositories. That is why they are responsible of \textit{version releasing} (see previous section): they check the work done by developers and decides if the code is stable enough to release it. Furthermore, if there are many private repositories of the same package they act as brokers of changes made in separate pools of developers.

\pagebreak

\section{Workspace}

The workspace is the place where developers work with packages (either those they develop or those they simply use). Technically, workspaces are local folder hierarchies in any station (server/demo/developers computers) that works with PID packages. A workspace is the place where packages repositories are created, developed and installed, and referenced given a predetermined pattern. As compared to classical "do as you wish" installation, the "workspace way of doing" as several advantages:
\begin{itemize}
\item there is a reference path in the deploy process in such a way that classifying and finding software artefacts is made easy.
\item there is no need to use system dependencies intensively for developed packages. As far as possible, every dependency should be satisfied by workspace content, except for system dependencies that cannot be packaged into workspace.
\item developers can handle many version of a package in the same build/execution environment, without risking to break OS dependencies. Furthermore they can used multiple versions of the same package in the same time.
\end{itemize}

\subsection{Workspace organization}

\subsubsection{Overview}
\label{sec:workspace}

A workspace is a folder (preferably named "workspace") with the following structure:
\begin{itemize}
\item the \textbf{.git} folder contains version control related information, managed by the git tool.

\item the \textbf{install} folder contains packages' binaries installed by the user. 
\item the \textbf{packages} folder contains all the packages developed by an author. Each sub-folder of \textbf{packages} is a local repository of a given package as presented previously.
\item the \textbf{external} folder contains all the external packages used by the installed package (source or binary). Each subdirectory corresponds to an external package, whose content is in turn completely undefined.
\item the \textbf{.gitignore} file is used to exclude  \textbf{install}, \textbf{packages} and \textbf{external} folders content from version control. This is mandatory since these folders content is supposed to be \textbf{ purely local a a user workstation}.
\item the \textbf{share} folder contains important files used to manage packages. The \textbf{docs} sub-folder contains documentation including the present document ; the \textbf{cmake} folder contains all scripts and data required to describe, build, install, deploy and configure packages: the \textbf{find} sub-folder contains cmake find script for commonly used external packages ; the \textbf{system} sub-folder contains generic scripts ; \textbf{patterns} contains cmake pattern files used ; \textbf{references} contains cmake script files with meta-information about available packages ; \textbf{licenses} contains cmake script files containing available license description; 
\end{itemize}

\subsubsection{Installing binary packages in the workspace}

The install folder contains installed binary version(s) of any package used by a user. Each of its direct sub directories is a folder representing a given installed package, that itself contains :
\begin{itemize}
\item as many folders as there are concurrent binary versions of the package installed. The name of the version folder reflects the installed package version it contains (e.g. : 1.3.5 ; 1.2.0, etc.). Version folder can be also local (correspond to an install from a source package currently developed in the workspace), in such a case they name is of the form : own-0.2.5, own-1.0.0, etc.)
\item an \textbf{installers} folder that contains all installable binary archives with each archive that corresponds to a specific version, for a specific system (linux, mac), in a specific mode (release, debug).
\end{itemize}


Each version folder is organized according to the following structure:
\begin{itemize}
\item the \textbf{bin} folder contains all executables provided by the package, except tests, in both debug and release modes. In other words it contains the result of the compilation of its corresponding package repository \textbf{include} folder.
\item the \textbf{include} folder contains the exported interfaces of libraries. Basically, its direct sub-folders are libraries' root folder hierarchically organized the same way as in the package repository \textbf{include} folder.
\item the \textbf{lib} folder contains libraries provided by the of the package in both debug and release modes.  In other words it contains the result of the compilation of its corresponding package repository \textbf{src} folder.
\item the \textbf{share} folder contains documents and scripts that are useful to the package users: the Use<Package><Version>.cmake file is a specific script file used to identify elements and dependencies of the binary package ; its \textbf{doc} sub-folder  contains API documentation generated by \textbf{doxygen} ; the \textbf{cmake} sub-folder contains cmake scripts files that are required to use the package, like find scripts used to configure external packages ; the config sub-folder contains installed element contained in the corresponding config folder of the package repository \textbf{src} folder.
\item the \textbf{license.txt} file describes the license that applies to the software. This is a copy of the license file in package repository.
\end{itemize}

\subsection{Workspace repository}

The \textbf{official workspace} is a git repository that can be modified only by \textbf{administrators} of the server. It contains cmake scripts used notably to:
\begin{itemize}
\item reference available packages (repositories and binary archives). Each time a new package is created it is referenced into the local workspace (by an administrator) and then changes in the official workspace are committed so that anyone can know the existence of this new package and can retrieve its hosting server. This does not mean that this person can use binary version or repository of this package, since this is bound to his access rights to the servers (at least one can know which person to call to get the rights).
\item provide available licenses description. These descriptions will be used in packages description.
\end{itemize}

The \textbf{official workspace} can be forked into \textbf{private workspaces}, exactly the same way as an \textbf{official package} (see figure~\ref{fig-collab}), to provide a common workspace for a team developing one or more packages at the same time. Once created new \textbf{users} and \textbf{developers} can be added to the private workspace repository. Private workspaces will be updated (by \textbf{developers} and \textbf{administrators}) with new references to packages, new licenses and new find scripts, while new packages are implemented. Then \textbf{official workspace} administrators can update its content, at any time, with the modifications made inside the private repository.

\pagebreak

\part{Tutorials}

This part of the document provides many tutorials 

\section{Work-flow management with git}

Now that all basic concepts and principles have been described, this last section shows how to use them during the development process.

\subsection{Installing Workspace and Packages}

The first phase when starting development consists in installing a workspace on the local  station of a developer or administrator, and configuring it adequately.

\subsubsection{Getting Last Workspace Version}

This phase simply consists in cloning the workspace repository. Any member of the robotic department can clone this repository, but only administrators can  modify it.

\begin{verbatim}
	git clone <global account>@<official server>:workspace.git
\end{verbatim}

When done the developer can start his work. The workspace is empty, which means it only contains available licenses description in \textbf{licenses} folder, references to available packages in \textbf{references} folder, generic package structure in \textbf{patterns} folder, \textbf{CMakeModules} folder with existing cmake scripts and a complete \textbf{categories} folder with links that target nothing. Its \textbf{packages} and \textbf{frameworks} are empty.

We have to notice that only \textbf{administrators} have direct write access to the official servers and developers may or not have read access. Consequently, developers cannot modify the workspace repository.
 
\subsubsection{Starting Development}

Then the \textbf{developer} has two choices:
\begin{itemize}
\item either he starts the development of a new package,
\item or he starts working on an existing package.
\end{itemize}

\paragraph{When a new package is created:}
\begin{enumerate}
\item an \textbf{administrator} creates an empty GIT repository and optionally an associated (sub)project (e.g. a \textit{redmine} project) on a given server (team or laboratory or open).
\item the \textbf{administrator} initializes the repository. On his local station he does:
\linebreak \verb|cd <workspace path>/packages/|
\linebreak \verb|git clone <global account>@<official server address>:<new package>.git|
\linebreak \verb|cd <new package>|
\linebreak \verb|cp -R ../../../patterns/package/ .|
\linebreak \verb|git tag -a v0.0.0 -m "creation of package"|
\linebreak \verb|git checkout -b develop master|
\linebreak \verb|git commit -a -m "initialization of package done"|
\linebreak \verb|git push origin master|
\linebreak \verb|git push origin develop|
\item the \textbf{administrator} creates a private account on the same or another server (or uses an existing one) and he clones the new repository in this account:
\linebreak \verb|git clone <global account>@<official server address>:<new package>.git|
\linebreak \verb|cd <new package>|
\item the \textbf{administrator} creates \textbf{feature branches} on private repository, by doing:
\linebreak \verb|git checkout -b feature-<feature name> develop|
\item the \textbf{administrator} registers the new developer (and any other person that may be involved in the development of this package) with ssh, so that he can access the git repository.
\item now \textbf{developers} can update/work with the private repository as they wish. To do this on their local working station they do :
\linebreak \verb|cd <workspace path>/packages/|
\linebreak \verb|git clone <private account>@<any server address>:<new package>.git|
\end{enumerate}

When done the development can start inside a package that is generic: it contains only the folder hierarchy and pattern files (e.g. doxyfile, CMakeList.txt, package.manifest, .gitignore) that matches the package structure defined in section 1.

\paragraph{When the developer start working on an existing package:} 
He either works on existing features or on new features. In the first case the \textbf{administrator} simply has to register the \textbf{developer} on the existing private server (step 5-6). In the second case, the administrator has to choose:
\begin{itemize}
\item if a new private repository has to be created, for instance, in order to isolate the work made on new branches (steps 3 to 6).
\item or if the developer uses an existing private repository with new branches (steps 4 to 6).
\end{itemize}
 
Whatever the solution chosen, the development starts in a package that already  contains some specific software artefacts and has "generic files" already configured. The developer may then need to install new existing packages.

\subsubsection{Installing Required Packages in the Workspace}

When starting development with an existing package, this later can have one or more dependencies with another packages and with system. System dependencies must be fulfil using classical install process provided by the OS. They can be found when compiling the package for the first time with \textbf{cmake}. Package dependencies are managed in another way:
\begin{enumerate}
\item to know which package are required, the developer has to look at the \textbf{package.manifest} file. The \texttt{dependency} markups list the required packages.
\item then the developer has to download and install these packages in its local workspace. To do so there are some alternatives:
\begin{itemize}
\item the developer has a \textbf{read access} to the official repository of the package (it is listed in the corresponding \texttt{dependency} markup). In this case he can simply do:
\linebreak \verb|cd <workspace path>/packages/|
\linebreak \verb|git clone <global account>@<official server>:<other package>.git|
\linebreak \verb|cd <other package>|
\linebreak \verb|git checkout tags/v<version compatible with requirements>|
\linebreak \verb|cd build|
\linebreak \verb|cmake ..|
\linebreak \verb|make|
\linebreak \verb|make install|
\item The developer can take a look at the \texttt{<package name>.manifest} file in the \textbf{references} folder of the workspace to know if there are installers available and if they match the required version. In this case, the developer uses the OS installer system and target the required package framework. For instance, for a package that is a simple archive :
\linebreak \verb|cd <workspace path>/frameworks/|
\linebreak \verb|ftp ftp://ftp.gforge.fr/<other package>-<version>.tgz|
\linebreak \verb|tar -xzvf <other package>-<version>.tar.gz|
\end{itemize}
\item When the last operation has been repeated for all packages, the frameworks of all packages contain adequate versions. Direct dependencies are resolved, but these required packages can in turn require other packages and OS dependencies. The current procedure has to be repeated recursively for each of these indirectly required packages.
\end{enumerate}

Once all the dependencies are satisfied, the development can truly start.

\subsection{Collaborative Software Development}

All \textbf{developers} only work around \textbf{private repositories} of packages, while \textbf{administrators} are responsible of the update of \textbf{official repositories} according to the changes done in private repositories. Nearly all developments in \textbf{private repositories} are made in \textbf{feature branches}. The \textbf{develop branch} is used to merge and to solve conflict between features.

\subsubsection{Developing a Feature}

Common feature branches are already created, so the only thing to do for developers is to navigate between available feature branches and add content in branches :
\begin{itemize}
\item Each time a developer wants to start making modification of a given feature (for instance at the beginning of the day):
\linebreak \verb|git checkout feature-<feature name>|
\linebreak \verb|git pull origin feature-<feature name>|
\linebreak \verb|=> solving potential conflicts|
\item During development of a feature, developers need to frequently "save" their work locally:
\linebreak \verb|git add <modified files>|
\linebreak \verb|git commit -m "<telling modifications>"|
\item Each time a developer wants to stop making modification of a given feature (for instance at the end of the day) or when important modification have been finished and committed:
\linebreak \verb|git pull origin feature-<feature name>|
\linebreak \verb|=> solving potential conflicts|
\linebreak \verb|git push origin feature-<feature name>|
\end{itemize}

During development on a feature branch, a developer may need to test some ideas without disrupting the work of all people working on the feature. In that case, he can work with a \textbf{new local branch} forked from feature branch. Modifications in this branch stay always local to the developer station. Furthermore modification should not be too big, these branches are used to test some ideas or to do bug fixes, not for developing big features (this is the role of feature branches) !
\begin{itemize}
\item Creating a local branch for testing an idea :
\linebreak \verb|git checkout feature-<feature name>|
\linebreak \verb|git pull origin feature-<feature name>|
\linebreak \verb|=> solving potential conflicts and testing|
\linebreak \verb|git push origin feature-<feature name>|
\linebreak \verb|git checkout -b <idea name> feature-<feature name>|
\item During development of the idea, frequently save the work locally:
\linebreak \verb|git add <all files modified>|
\linebreak \verb|git commit -m "<telling modifications>"|
\item When idea is OK and can be integrated to the feature:
\linebreak \verb|git pull origin/feature-<feature name>|
\linebreak \verb|=> solving potential conflicts and testing|
\linebreak \verb|git rebase origin/feature-<feature name>|
\linebreak \verb|git checkout feature-<feature name>|
\linebreak \verb|git merge <idea>|
\linebreak \verb|git branch -d <idea>|
\linebreak \verb|git push origin feature-<feature name>|
\item otherwise if the idea is not good:
\linebreak \verb|git checkout feature-<feature name>|
\linebreak \verb|git branch -d <idea>|
\end{itemize}

The idea behind the use of the rebase command is to let the history of the feature development as linear as possible, in order to 

\subsubsection{Integrating Features}

During development process, features have to be incrementally integrated as soon as their development is finished and they have been tested. The integration can be done either by developers or administrators, but in all cases it requires every developers of the feature to be aware of this, to avoid big troubles.
\begin{enumerate}
\item Merging the feature in the development branch:
\linebreak \verb|git checkout feature-<feature name>|
\linebreak \verb|git pull origin develop|
\linebreak \verb|=> solving conflicts and testing|
\linebreak \verb|git checkout develop|
\linebreak \verb|git merge --no-ff feature-<feature name>|
\linebreak \verb|=> solving conflicts and testing|
\item Deleting the feature branch:
\linebreak \verb|git push origin develop|
\linebreak \verb|git push origin --delete feature-<feature name>|
\item Updating in local repository the branch that has been removed in remote repository (all users of the repository) :
\linebreak \verb|git remote prune origin|
\linebreak \verb|git branch -d feature-<feature name>|
\end{enumerate} 

\paragraph{Remarks:}
\begin{itemize}
\item The development of features is made in parallel and they are merged indirectly in the \textbf{develop branch} at the very end, one at a time: features don't synchronize until merge. This let the possibility to developers to change some parts of the API/structure without immediately impacting the work made on others features.
\item The best way is to first create an initial feature branch that puts in place the general basis of the package (API, basic class hierarchy, etc.). Then, when this feature has been merged in develop branch, parallel development into many feature branches can start.
\item When merging, the resolution of conflicts \textbf{must be realized in feature branch} to avoid any problem in the develop branch while conflicts resolution take place.
\end{itemize}

\subsection{Releasing a Package Version}

Releasing package versions is the responsibility of administrators.

The first step is the update of the administrator station with modifications contained in private repository (named \texttt{private}):
\begin{enumerate}
\item Merging develop into master:
\linebreak \verb|git checkout develop|
\linebreak \verb|git pull private develop|
\linebreak \verb|git checkout master|
\linebreak \verb|git merge --no-ff develop|
\linebreak \verb|doing test and solving conflicts, if any|
\linebreak Incrementing the version number in \textbf{package.manifest} file to get \texttt{<new version number>}.
\linebreak \verb|git commit -a -m "Bumped version to <new version number>"|
\linebreak \verb|git tag -a v<new version number>|
\item Updating private repository with new release version (to simply update the \textbf{package.manifest} file):
\linebreak \verb|git checkout develop|
\linebreak Incrementing the version number in \textbf{package.manifest} file to get \texttt{<new version number>}.
\linebreak \verb|git commit -a -m "Bumped version to <new version number>"|
\linebreak \verb|git push private develop|
\linebreak \verb|git push private master|
\end{enumerate}

The second step consists in updating the official repository (named \texttt{origin} for the administrator):
\begin{enumerate}
\item Getting branches from official repository:
\linebreak \verb|git checkout develop|
\linebreak \verb|git pull origin develop|
\linebreak \verb|doing test and solving conflicts, if any|
\linebreak \verb|git checkout master|
\linebreak \verb|git pull origin master|
\linebreak \verb|doing test and solving conflicts, if any|
\item Update the master and develop branches:
\linebreak \verb|git push origin develop|
\linebreak \verb|git push origin master|
\end{enumerate}


\subsection{Developing a Hotfix}

Creating a hot fix is always made on demand of an administrator, but can be realized either by himself or a developer. The process is quite the same as for features, but we suppose that only one developer is involved in this task, that should be quick: 
\begin{enumerate}
\item a package private repository is created or an existing one is used.
\item The administrator gets the last released version number from \textbf{package.manifest} file (e.g. 1.2.0) and increments the patch version number to get the <new patch version number> (e.g. 1.2.1).
\item Creating the hotfix branch in the private repository:
\linebreak  \verb|git checkout -b hotfix-<new patch version number> master|
\item During the bug correction, committing locally:
\linebreak \verb|git checkout hotfix-<new patch version number>|
\linebreak \verb|git add <modified files>|
\linebreak \verb|git commit -m "<commit message>"|
\item Saving work in the private repository:
\linebreak \verb|git push origin hotfix-<new patch version number>|
\end{enumerate}

When bug or security problems have been solved and tested, the development of the hotfix is finished. This is then the only time when the master branch can be modified in the private repository:
\begin{enumerate}
\item The responsible of the hotfix releases it:
\linebreak \verb|git checkout hotfix-<new patch version number>|
\linebreak \verb|changing version number is package.manifest file|
\linebreak \verb|git commit -a -m "Bumped version to <new patch version number>"|
\linebreak \verb|git checkout master|
\linebreak \verb|git merge --no-ff hotfix-<new patch version number>|
\linebreak \verb|git tag -a v<new patch version number>|
\linebreak \verb|git push origin master|
\linebreak \verb|git checkout develop|
\linebreak \verb|git merge --no-ff hotfix-<new patch version number>|
\linebreak \verb|doing some conflicts resolution if necessary|
\linebreak \verb|git push origin develop|
\item Then the hotfix branch is deleted:
\linebreak \verb|git branch -d hotfix-<new patch version number>|
\linebreak \verb|git push origin --delete hotfix-<new patch version number>|
\end{enumerate}

Then the last step consists in releasing the patch version on the official server. This is the role of administrators that do that on their own station:
\begin{enumerate}
\item Updating master and develop branches:
\linebreak \verb|git pull private develop|
\linebreak \verb|git pull private master|
\item Checking that the hotfix solves the problem and that everything is OK.
\item Updating official repository branches:
\linebreak \verb|git push origin develop|
\linebreak \verb|git push origin master|
\end{enumerate}


\subsection{Updating workspace}

Updating the workspace repository must be done:
\begin{itemize}
\item when a new package has been created and first released version has been published on package official server: the \textbf{package.manifest} file must be added  and renamed to the \textbf{references} folder of the workspace.
\item when a new version of an existing package has been release on a package official server: the corresponding \textbf{package.manifest} in the the \textbf{references} folder of the workspace must be updated.
\item when a new license is used in a \textbf{package.manifest} file: the corresponding license file must be added to the \textbf{licenses} folder of the workspace.
\item when categories defined in a \textbf{package.manifest} file have changed: the folders for new (sub)categories have to be created ; the link to the package framework have to be created or suppressed (when the package has been removed from a category).
\item when a new package is released on official server and it targets some categories: links to that packages have to be added to target (sub)categories folders.
\end{itemize}
 
The update of the workspace is the work of the \textbf{administrators} only: they are responsible to guarantee the coherence of workspace repository structure and content.

\subsubsection{Adding references to packages}

When a package is added to the workspace official repository, on its local workstation an administrator of the package does:
\begin{enumerate}
\item Referencing the package in the workspace:
\linebreak \verb|cd <path to the package>|
\linebreak \verb|git pull origin master|
\linebreak \verb|git checkout master|
\linebreak \verb|cp package.manifest ../../references/<nameofpackage>.manifest|
\linebreak \verb|git commit -a -m "adding package <package name>"|
\item Looking package license in \textbf{package.manifest} and if the license does not exists in workspace create the corresponding license file:
\linebreak \verb|cd <path to the workspace>|
\linebreak \verb|cp patterns/license.license licenses/<licensename>.license|
\linebreak \verb|writing the new license file...|
\linebreak \verb|git commit -a -m "adding license <license name>"|
\item Looking package categories in \textbf{package.manifest} file, and if categories do not exist, create them:
\linebreak \verb|cd <path to the workspace>/categories|
\linebreak \verb|mkdir <category path>|
\linebreak \verb|git commit -a -m "adding category <category name>"|
\item Adding a link to the package framework in each category folder defined in \textbf{package.manifest} file:
\linebreak \verb|cd <path to the workspace>/<path to category folder>|
\linebreak \verb|ln -s -t . <relative path to workspace root>/frameworks/<package name>|
\linebreak \verb|git commit -a -m "adding link to <package> in <category name>"|
\item If a package requires some system dependencies that the administrator think to be relevant for many developers, he can add the cmake script files used to configure these dependencies to the \textbf{CMakeModules} folder of the workspace.
\linebreak \verb|cd <path to the workspace>/CMakeModules|
\linebreak \verb|cp <path to the workspace>/packages/<name of package>/|
\linebreak \verb| CMakeModules/<chosen dependency>.cmake .|
\linebreak \verb|git commit -a -m "adding cmake script for <dependency>"|
\item Updating the workspace official repository:
\linebreak \verb|cd <path to the workspace>|
\linebreak \verb|git pull origin master|
\linebreak \verb|solving potential conflicts|
\linebreak \verb|git push origin master|
\end{enumerate}

\subsubsection{Removing references to packages}

The process is quite the same as previously except that only the package reference file is suppressed from the workspace references folder, not the license files or the categories.
\begin{enumerate}
\item Removing the package reference:
\linebreak \verb|cd <path to the workspace>/references|
\linebreak \verb|rm <package name>.manifest|
\linebreak \verb|git commit -a -m "removing package <package name>"|
\item Updating the workspace official repository:
\linebreak \verb|cd <path to the workspace>|
\linebreak \verb|git pull origin master|
\linebreak \verb|solving potential conflicts|
\linebreak \verb|git push origin master|
\end{enumerate}

\subsubsection{Updating references to packages}

The update of a package reference must be done \textbf{each time a new version of the package is released} in the official repository of the package. The process is the same as for adding the package reference for the first time, except for categories:

\begin{enumerate}
\item Looking package categories in the new version of the \textbf{package.manifest} file, and if categories do not exist, create them:
\linebreak \verb|cd <path to the workspace>/categories|
\linebreak \verb|mkdir <category path>|
\linebreak \verb|git commit -a -m "adding category <category name>"|
\item Adding a link to the package framework in each category folder defined in \textbf{package.manifest} file:
\linebreak \verb|cd <path to the workspace>/<path to category folder>|
\linebreak \verb|ln -s -t . <relative path to workspace root>/frameworks/<package name>|
\linebreak \verb|git commit -a -m "adding link to <package> in <category name>"|
\item Removing links in each category folder no more defined in \textbf{package.manifest} file:
\linebreak \verb|rm <path to the workspace>/<path to old category folder>/<package name>|
\item Updating the workspace official repository:
\linebreak \verb|cd <path to the workspace>|
\linebreak \verb|git pull origin master|
\linebreak \verb|solving potential conflicts|
\linebreak \verb|git push origin master|
\end{enumerate}

\pagebreak

\section{Package development with CMake}

When developing a package one need to handle information such as:
\begin{itemize}
\item \textit{meta-information}: who is involved in its development ? what is its general purpose ? where to find this package on the network ? what is the license of the code ? etc.
\item \textit{build-related information}: what are the components provided by the package and how to compile/link them from source code ?  How components are tested ? what is the version of the package ? what are its functional dependencies ?
\item \textit{functional information}: this is the source code of the components and other associated files like configuration files if any required.
\end{itemize}

The whole package development is organized and described with cmake, and the CMakeList.txt files used contain the whole \textit{meta-information} and \textit{build-related information} used by the package. Each package contains several CMakeList.txt files:
\begin{itemize}
\item the root CMakeList.txt file (direct leaf of the package source repository, see section~\ref{sec:PackageStruct}) is used to define \textit{meta-information} and \textit{dependencies} of the package.
\item the CMakeList.txt file contained in the \textbf{src} folder defines the \textbf{library components} (see section~\ref{sec:Package}).
\item the CMakeList.txt file contained in the \textbf{apps} folder defines the \textbf{application components} (see section~\ref{sec:Package}).
\item the CMakeList.txt file contained in the \textbf{test} folder defines the \textbf{test components} (see section~\ref{sec:Package}) and running tests (using these components or others).
\item the CMakeList.txt file contained in the \textbf{share} folder defines additional files to install, like configuration files used by libraries and/or applications (if any), documents, etc.
\end{itemize}

Each of these CMakeList.txt files must follow a predefined pattern. This pattern in mainly influenced by the use of PID specific CMake functions. The following subsections present examples on how to use these functions together with more classical CMake code in order to completely define a PID package.

\subsection{Package's root CMakeList.txt file}
\label{sec:rootCMake}

\subsubsection{General Meta-Information}
\label{sec:rootCMakeGeneral}

Let's suppose we define a package with the name "the-testpack-b", its root CMakeList.txt file could look like this.

\begin{verbatim}
PROJECT(the-testpack-b)
CMAKE_MINIMUM_REQUIRED(VERSION 2.8.11)
set(WORKSPACE_DIR ${CMAKE_SOURCE_DIR}/../.. CACHE PATH "root of 
the packages workspace directory")
list(APPEND CMAKE_MODULE_PATH ${WORKSPACE_DIR}/share/cmake/system) 
# using generic scripts/modules of the workspace
include(Package_Definition)

declare_PID_Package(	
    AUTHOR      Robin Passama 
    INSTITUTION LIRMM 
    YEAR        2013 
    LICENSE     CeCILL
    ADDRESS     git@idh.lirmm.fr:perso/passama/the-testpack-b.git
    DESCRIPTION 	test package B for PID
)

set_PID_Package_Version(1 1)

# adding some binary packages references
add_PID_Package_Reference(
    BINARY VERSION 0 1 0 SYSTEM linux 
    URL 	
    http://lirmm.lirmm.fr/FileX/get?auto=1&k=rfYTf1gkpI5XtEpQWVA		
    http://lirmm.lirmm.fr/FileX/get?auto=1&k=oMyg4JVeeKYWpqwEFxE
)

add_PID_Package_Reference(	
    BINARY VERSION 1 1 SYSTEM linux 
    URL 
    http://lirmm.lirmm.fr/FileX/get?auto=1&k=DYt2j35Kw8ozOgHfoVA
    http://lirmm.lirmm.fr/FileX/get?auto=1&k=zEx02N4KWfzDWPTxiO
)
\end{verbatim}

Exactly as in any CMake project, the CMake package is define with the PROJECT keyword. The project's name \textbf{is the name of the package root folder} (and so the name of the repository). The remaining lines until the \texttt{declare\_PID\_Package} macro call must be let \textbf{unchanged} (initialization of the PID specific cmake scripting system).

Then comes the \texttt{declare\_PID\_Package} macro, which is mandatory. This macro defines general meta-information on the package, and should not change a lot during package life cycle: 
\begin{itemize}
\item the main author (AUTHOR keyword) and its institution (INSTITUTION optional keyword), considered as the maintainer of the package. The main author is an \textbf{administrator} of the package (see section~\ref{sec:gitrepositories}).
\item the YEAR field helps defining the package's life cycle range. For instance one can input a field such as "2009-2013".
\item the LICENSE field is used to specify the license that applies to the code. This license must be defined in the workspace (see section ~\ref{sec:workspace}) in the form of a \textbf{cmake script license file}.
\item the ADDRESS field is used to specify the address of the \textbf{official GIT repository} of the package (see section~\ref{sec:gitrepositories}).
\item the field DESCRIPTION must be filled with a short description of the package usage/utility.
\end{itemize}
~\\

Then the user fill other meta-informations that evolve during project life cycle:
\begin{itemize}
\item the \texttt{set\_PID\_Package\_Version} function is used to set the currently developed version of the package. It take at least a MAJOR and MINOR numbers and optionally a PATCH number as arguments (default value for PATCH number is 0). The version number thus follows the same pattern as git \textbf{release versions}. Before a version is released with a git tag (see section~\ref{sec:versiontags}) this version number must be set adequately so that git tag matches cmake package version. Generally, the best way to do is set the version number used in the CMakeList.txt with the number of the next version to release.
\item the \texttt{add\_PID\_Package\_Reference} function is used to register a downloadable binary version of the package. The VERSION keyword specify the version with MAJOR MINOR PATCH numbers. The SYSTEM keyword specifies the target operating system for which the binaries have been built. The two addresses after the URL keyword specify where the binary package version can be downloaded either in release (first address) and debug (second address) modes.
\end{itemize}

\subsubsection{Dependencies with other packages}
\label{sec:rootCMakeDeps}

The last part of the root CMakeList.txt is used to manage dependencies between the current package and other packages it depends on. It could look like this:

\begin{verbatim}
# finding used packages
find_package (Boost REQUIRED)
find_package (the-testpack-a 1.0 REQUIRED lib-b-sh lib-x)

# declare a dependency over Boost (by default boost root is the 
# /usr system install dir)
if(Boost_DIR-NOTFOUND)
     set(BOOST_ROOT /usr)
endif()
declare_PID_Package_Dependency(PACKAGE Boost EXTERNAL 
${BOOST_ROOT} VERSION "${Boost_MAJOR_VERSION}.
${Boost_MINOR_VERSION}.${Boost_SUBMINOR_VERSION}")

#declare a dependency over the-testpack-a PID package
declare_PID_Package_Dependency (
                PACKAGE the-testpack-a
                PID VERSION 1 0 
                COMPONENTS lib-b-sh lib-x)
                
build_PID_Package()
\end{verbatim}

The \texttt{find\_package} function is a standard cmake function used to find and configure other packages. In the example, we search for a package named "the-testpack-a" (that is also a PID package) with version compatible with 1.0 (for PID packages compatibility as the same meaning as in section~\ref{sec:versiontags}, otherwise the meaning is package dependent). The package is REQUIRED meaning that it must be found.  We specifically require the \textbf{components} named "lib-b-sh" and "lib-x". As experienced CMake users may notice there is no difference in the usage of the \texttt{find\_package} function as regard of its standard use. 

Then PID development process imposes to declare dependencies of the current package. Indeed this is not because you try to find other package that you will use them, even if obviously this assumption will be right most of time. A dependency simply means that components of the package are using components from other packages (see section~\ref{sec:Package} to understand what is a component). For instance, the current package uses the package "the-testpack-a" with minimum version 1.0. To make this declaration possible PID provides the \texttt{declare\_PID\_Package\_Dependency} function. This function can be used in two different ways:
\begin{itemize}
\item it is used to specify a dependency to an \textbf{external package} (using the keyword EXTERNAL after the package name). An external package is just a \textit{reference} associated to a path that points to the root folder of a \textbf{NON PID} package. This reference will be used later when defining components. A version information can be appended but is not used. A good way to do is to install external package into the \textbf{external} folder of the workspace, when possible, so that they will be managed by PID in a easier way. External package are packages installed by hand by the user in his file system, either in system or add-hoc folders. For packages that are supposed to be part of the operating system, there is no need to specify the dependency since this dependency is satisfied "by default" by the system.
\item it is used to specify a dependency to a PID package (using PID keyword). Then version and component requirement informations can be used exactly as in the example. Relationship between PID packages are stronger since their discovering/install configuration will be done automatically.
\end{itemize}

Finally, the CMakeList.txt file call the \texttt{build\_PID\_Package} function. This line is mandatory in order to allow the build of the package: compilation, installation, deployment, API doc generation, etc. Without this call, the CMake process would simply do nothing.

\subsubsection{Dealing with conditional dependencies}
\label{sec:rootCMakeComplexDeps}

The previous example is quite simple since it directly deals with \textbf{required} dependencies. Nevertheless, when using cmake one sometimes have to deal with \textbf{conditional dependencies}. Indeed, \textbf{conditional dependencies} allow to configure the build according to the OS requirements or to the configuration of user's station. This conditional dependencies are managed according to the following pattern (or a derivative from this solution):
\begin{verbatim}
find_package(the-testpack-a)
if(the-testpack-a_FOUND)
    set(USE_the-testpack-a TRUE CACHE INTERNAL "" FORCE)
     declare_PID_Package_Dependency (PACKAGE the-testpack-a
                PID VERSION 1 0 COMPONENTS lib-b-sh lib-x)
else()
    set(USE_the-testpack-a FALSE CACHE INTERNAL "" FORCE)
    find_package(the-testpack-x)
    if(the-testpack-x_FOUND)
       set(USE-the_testpack-x TRUE CACHE INTERNAL "" FORCE)
       declare_PID_Package_Dependency (PACKAGE the-testpack-x
                PID VERSION 1 3 COMPONENTS lib-any)
    else()
       set(USE-the_testpack-x FALSE CACHE INTERNAL "" FORCE)
       MESSAGE("alternative system dependency not satisfied. 
       Install/select either the-testpack-a or the-testpack-x")
       return()       
    endif()
endif()
\end{verbatim}

Conditional dependencies is used to describe dependencies that are optional or to describe an alternative requirement when multiple different packages can be used for the same purpose. This later case is shown in the previous code. Defining such conditional dependencies is made using classical CMake mechanism (using \texttt{find\_package} and \texttt{option}/\texttt{set} commands) is combination with the \texttt{declare\_PID\_Package\_Dependency} function previously explained. In the previous example, there is an implicit priority in the usage of required packages: "the-testpack-a" will be used prior to "the-testpack-x" if it is found. The CMakeList.txt file can also use the \texttt{option} command to let the user select its preferred package. The only mandatory descriptive elements are:
\begin{itemize}
\item if a package is to be used, \textbf{whether it has been previously found or not}, then the \texttt{declare\_PID\_Package\_Dependency} function \textbf{must be called} to tell to PID system which package (PID or external) is required.
\item Each possibly used package must be bound to a CMake \textbf{variable that indicates if the package is really used or not}. For instance see the variable \texttt{USE\_the-testpack-a}. These variables will be used later, when declaring components, to know how to configure component dependencies according to required packages.
\end{itemize}

\subsection{Defining Library components}
\label{sec:libCMake}

Once package dependencies have been defined, the package developers can then define components of the package and their relationship with these dependencies. Most common components are library components : they are used by developers to define reusable functionalities. All libraries are defined in the CMakeList.txt file contained in the \textbf{src} folder of the package repository.

PID defines three types of libraries, matching the three classical  types available in C/C++. It provides a systematic way to define these libraries and automate their use, avoiding the user to know precisely how to deal with each type and their relative properties. Following subsections explain how to declare each of these types. These definitions rely on cmake functions provided by PID: \texttt{declare\_PID\_Component} and \texttt{declare\_PID\_Component\_Dependency} (see appendix~\ref{sec:PIDCMakefunctionsAPI}).

\subsubsection{Header libraries}
\label{sec:libCMakeHeader}

Header libraries are not compiled to produce a binary object. They are just made of a set of header files. This kind of library used is often used for template libraries definitions, for instance the Boost library. Such a library is never used at link time (never linked to another library or executable using a linker) but only at compile time (when including header files). The definition of a header lib should look like:
\begin{verbatim}

declare_PID_Component(HEADER_LIB NAME lib-y DIRECTORY lib_y)
declare_PID_Component_Dependency(COMPONENT lib-y 
               EXPORT DEPEND lib-x PACKAGE the-testpack-a
               EXPORTED_DEFINITIONS USE_EXTERNAL_LIB_X)

\end{verbatim}

The first thing to do is to declare the header library by using the function \texttt{declare\_PID\_Component}:
\begin{itemize}
\item the HEADER\_LIB keyword is used to declare a header library.
\item the NAME keyword is used to define the identifier of the component in PID, whose unicity must be preserved. In the example the name is "lib-y".
\item the DIRECTORY keyword is used to say in which sub-directory of the \textbf{include} folder the header files are found, in the example the "lib\_y" sub-folder. The direct consequence is that all headers of a given library \textbf{must be placed in a unique folder}.
\end{itemize}
 
Then, depending on the library content, some dependencies can be attached to the library, using \texttt{declare\_PID\_Component\_Dependency}. Indeed a header library can depend on other libraries, either header, static or shared:
\begin{itemize}
\item the COMPONENT keyword is used to specify for which component a dependency is defined, in the example the previously defined "lib-y" header library.
\item the EXPORT keyword specifies that the lib-y component export the required dependency. Exporting means that the reference to the required component is defined in the interface of the library. Since a header lib is only made of an interface, \textbf{it must export each of its dependencies}.
\item the DEPEND and PACKAGE keywords are used to specify the dependency: here the lib-y header library depends on the component "lib-x" of the PID package "the-testpack-a". Declaring an external or system dependency or even an internal dependency is slightly, but follows the same logic, see appendix~\ref{sec:PIDCMakefunctionsAPI}.
\item the EXPORTED\_DEFINITIONS is used to specify values of C preprocessor definitions that are exported by the library. In the example the exported definition is \texttt{USE\_EXTERNAL\_LIB\_X}. exported definition are used by components that will use lib-y to configure its code adequately. Since a header lib is only made of an interface, all its definitions must be exported and it can have no internal definitions.
\end{itemize}

On interesting property of PID is to be able to declare different components from the same code. For instance:
\begin{verbatim}

declare_PID_Component(HEADER_LIB NAME lib-y-bis DIRECTORY lib_y
                      EXPORTED_DEFINITIONS NUSE_EXTERNAL_LIB_X)

\end{verbatim}

In this later example, a new component named "lib-y-bis" is created from the same source code contained in the lib\_y folder. The differences with the previous component are that the "lib-y-bis" has no dependencies and it undefines (using N in front of the preprocessor definition) the definition \texttt{USE\_EXTERNAL\_LIB\_X}. This is useful to declare many alternatives from the same code.

\subsubsection{Static libraries}
\label{sec:libCMakeStatic}

Static libraries are binary archives that define some functionalities. A static library is made of:
\begin{itemize}
\item a set of header files that define its interface (i.e. what is available for library users).
\item a set of (compiled) binary objects that implement its behaviour.
\end{itemize}
Its interface is used at compile time (when its header are included) and its contained objects are linked to executables and shared libraries at link time, so they no more exist at run time. The definition of a static lib should look like:

\begin{verbatim}

declare_PID_Component(STATIC_LIB NAME lib-c-st DIRECTORY lib_c
                  INTERNAL DEFINITIONS NA_VERY_SPECIFIC_IMPLEM)
declare_PID_Component_Dependency(COMPONENT lib-c-st
                  EXTERNAL Boost INCLUDE_DIRS <Boost>/include)
declare_PID_Component_Dependency(COMPONENT lib-c-st 
                  EXPORT DEPEND lib-y-bis)

\end{verbatim}

As for any component, the first thing to do is to declare by using the function \texttt{declare\_PID\_Component}:
\begin{itemize}
\item the STATIC\_LIB keyword is used to declare a static library.
\item the NAME keyword is used to define the identifier of the of the static library, "lib-c-st" in the example.
\item the DIRECTORY keyword is used to say in which sub-directory of the \textbf{include} folder the header files of the static library are found, in the example the "lib\_c" sub-folder. The \textbf{same folder name} is used to specify in which subdirectory of the \textbf{src} folder the source and non-public header files of the library are found. For a same library, this constraints the user to use same folder names between \textbf{include} and \textbf{src} directories.
\item the INTERNAL DEFINITIONS is used to specify definitions that affect only the implementation (i.e. that is not used in any header file of the library). In the example the "lib-c-st" undefines the preprocessor definition A\_VERY\_SPECIFIC\_IMPLEM .
\end{itemize}

As readers can notice, the declaration is quite the same as for header libraries. Note also that static libraries can define exported definitions (as header libraries) for those which are used in their header files. The declaration of dependencies also follows the exact same pattern. In the example:
\begin{itemize}
\item "lib-c-st" static library is using an external package named "Boost". As boost is a pure header library it only needs to specify where to find its header files, using the INCLUDE\_DIRS keyword. The include path specified is relative to the Boost package root folder (using the <Boost> specifier).
\item "lib-c-st" is also using (specified with keyword DEPEND) another library "lib-y-bis" that is defined in the same package (since no PACKAGE keyword is used). It exports "lib-y-bis" meaning that its header files contain include directive over header files of the "lib-y-bis".
\end{itemize}


\subsubsection{Shared libraries}
\label{sec:libCMakeShared}

Shared libraries are binary objects that define some functionalities. A shared library is made of:
\begin{itemize}
\item a set of header files that define its interface (i.e. what is available for library users).
\item a binary object (.so on linux) that implements its behaviour. This 
\end{itemize}
Its interface is used at compile time (when including its headers) and its binary object checked at link time and truly used at run time, either when the executable using it is loaded or when it explicitly load it at run time. The definition of a shared lib is more or less the same as for static libraries and should look like:

\begin{verbatim}

declare_PID_Component(SHARED_LIB NAME lib-c-sh DIRECTORY lib_c
                   INTERNAL DEFINITIONS A_VERY_SPECIFIC_IMPLEM)
declare_PID_Component_Dependency(COMPONENT lib-c-sh
                   EXTERNAL Boost INCLUDE_DIRS <Boost>/include)
declare_PID_Component_Dependency(COMPONENT lib-c-sh
                   EXPORT DEPEND lib-y)

\end{verbatim}

In the previous example, the function \texttt{declare\_PID\_Component} is used in a common way:
\begin{itemize}
\item the SHARED\_LIB keyword is used to declare a shared library.
\item the NAME keyword is used to declare "lib-c-sh".
\item the DIRECTORY keyword is used to define \textbf{include} and \textbf{src} sub folders where to find code. In the example reader can notice that the shared library "lib-c-sh" is built from the same code as static library "lib-c-st".
\item the INTERNAL DEFINITIONS is used to specify to define the preprocessor definition A\_VERY\_SPECIFIC\_IMPLEM contrarily to "lib-c-st".
\end{itemize}

This example shows how shared and static libraries can be built from the same source code and how developers can define alternative implementation for part of their code using preprocessor definitions. Their dependencies can also vary:
\begin{itemize}
\item "lib-c-sh" shared library is using the Boost external package the same way as "lib-c-st".
\item "lib-c-sh" is using (specified with keyword DEPEND) the library "lib-y" (that is defined in the same package)  instead of "lib-y-bis" used by "lib-c-st".
\end{itemize}


\subsection{Defining Application components}
\label{sec:appCMake}

In order to produce programs usable by end-user package can also contain application components. Application components that are designed to be used by end-users are defined in the CMakeList.txt file contained in the \textbf{apps} folder of the package repository. Test applications are specifically used to test package libraries or applications and are placed in the \textbf{test} folder of the package repository.

PID defines three types of applications explained in following subsections. These definitions rely on same cmake functions already presented in libraries component section (see also appendix~\ref{sec:PIDCMakefunctionsAPI}).

\subsubsection{Standard applications}
\label{sec:appCMakeStandard}

By standard application we mean application that are to be used by end-users of the package, or a run-time software component that can be deployed using a middleware. The definition of a standard application  should look like:
\begin{verbatim}

declare_PID_Component(APPLICATION NAME app-b1 DIRECTORY app_B1
                 INTERNAL INCLUDE_DIRS common_defs common_types)
declare_PID_Component_Dependency(COMPONENT app-b1 
                 DEPEND lib-b-sh PACKAGE the-testpack-a)

\end{verbatim}

As for library components (see ~\ref{sec:libCMake}), the first thing to do is to declare the application by using the function \texttt{declare\_PID\_Component}:
\begin{itemize}
\item the APPLICATION keyword is used to declare a standard application.
\item the NAME keyword is used to define the unique identifier of application, "app-b1" in the example.
\item the DIRECTORY keyword is used to say in which sub-directory of the \textbf{app} folder the source files of the application are found, in the example the "app\_B1" sub-folder.
\item the INTERNAL INCLUDE\_DIRS allows to specify additional directories (sub folders of the \textbf{apps} folder) where to find non-public header files, in the examples folders "common\_defs" and "common\_types".
\end{itemize}

Then developers can add dependencies for the application, exactly the same way as for libraries using the  \texttt{declare\_PID\_Component\_Dependency} function:
\begin{itemize}
\item the COMPONENT keyword is used to specify the application that declares a dependency, "app-b1" in the example.
\item DEPEND and PACKAGE keyword are used to target a specific component from another package, here the shared library "lib-b-sh" of the package "the-testpack-a". Dependencies management work the same way as for libraries.
\end{itemize}


\subsubsection{Example applications}
\label{sec:appCMakeExample}

Example applications are little pieces of executable code whose only purpose is to provide to developers simple way of using libraries defined in the package. The definition of an example application  should look like:
\begin{verbatim}

declare_PID_Component(EXAMPLE_APPLICATION NAME ex-b DIRECTORY ex_b)
declare_PID_Component_Dependency(COMPONENT ex-b DEPEND lib-b-sh )

\end{verbatim}

From a strict C/C++ point of view example application are just like standard application, in other word an executable binary object. From PID point of view this is also nearly the same:
\begin{itemize}
\item Example application are developed with same rules as standard application except that we have to use the EXAMPLE\_APPLICATION keyword within \texttt{declare\_PID\_Component} function (see previous code).
\item Developers can decide (using dedicated CMake option in cache) to avoid compiling example applications since most of time they are not really useful.
\item Example application code is integrated into the API documentation.
\end{itemize}

\subsubsection{Test units}
\label{sec:testCMake}

The \textbf{test} subdirectory contains a CMakeList.txt file that builds test units. The organization into subdirectories follows the same logic as for libraries and applications.

TODO

When the code has compiled and linked correctly a good practice is to test it to be sure it behaves properly or respects some backward compatibility constraints. To do so we use test units built during the build process or any other interesting test tool and directly integrate the testing in the CMakeFile.txt of the \textbf{test} folder using CTest tooling integrated in cmake:

\begin{verbatim}
...
enable_testing()

add_test(<test1 name> <test unit 1> arg1 arg2 ... )
add_test(<test2 name> <test unit 1> arg1 arg2 ... )
add_test(<test3 name> <test unit 2> arg1 arg2 ... )
...
endif(<package>_WITH_TESTS)
\end{verbatim}

This will automatically generate a sequence of tests whose result is \textbf{PASSED} or \textbf{FAILED} once the user input the \texttt{make test} command. We can also log results of tests into a dashboard using the same CTest tool, but this discussion is beyond the topics of this document.

TODO

\subsection{Generating API documentation}
\label{sec:apiCMake}

When a library is defined, it is intended to be used by third party developers. To this end, it is always useful to have a clear way to consult the API provided by this library. The api documentation has to be as close as possible to the source code, that is why the best way is to use an api documentation generation tool like \textbf{doxygen} and to automate its use directly during the build process. We choose \textbf{doxygen} because it is a cross-platform tool very well suited for C/C++ code. 

PID automatically manage the generation of API documentation with doxygen. The generated doc is installed in the binary package version folder in the share/doc/html sub-folder. It is also possible to generate an equivalent latex document (pdf) that it will placed in the  
share/doc/latex sub-folder, if latex is installed on the building host. The developers of a package can configure this generation in two ways, presented in following subsections.

\subsubsection{Documenting headers}
\label{sec:apiCMakeHeaders}


The API documentation requires that the users document the header files contained in each sub-folder of the \textbf{include}. The way to document headers is defined by doxygen tooling. Generally speaking, it consists in defining comments with specific format in header file code. As an example, the comment at the beginning of a header file should look like this:

\begin{verbatim}
/** 
 * @file MPO700interface.h 
 * @author Robin Passama
 * @brief interface of the neobotix communication library. 
 * @example pc_side_simple_interface.c
 * Created on June 2013 18.
 * License : CeCILL-C.
 */

#ifndef MPO700_INTERFACE_H
#define MPO700_INTERFACE_H
...
\end{verbatim}
In this example are specified general information about the header:
\begin{itemize}
\item the \texttt{@file} property specifies the name of the file.
\item the \texttt{@author} property gives names of authors of the file.
\item the \texttt{@brief} property gives a quick description of the header purpose.
\item  the \texttt{@example} property allows to specify a source code giving an example on how to use the API defined below. This property should refer to the source code of example applications.
\end{itemize}

Then developers have to document each of their functions/methods and classes/structures/enumerations by putting a comment before their declaration, the same way as:
\begin{verbatim}
/**
* Function used to initialize the communication interface with  
* the robot (must be called before any other call). 
* By default the robot is in monitor mode just after this call.
* @brief initialize communication with robot.
* @param [in] if_name is the name of the eternet interface used
* for communication (e.g. eth0).
* @param [in] mpo700_ip is the IPV4 address of the robot.
* @return 0 if initialization failed, 1 otherwise
*/
int init_MPO700_Robot(char* if_name, char * mpo700_ip);
...
\end{verbatim}

This example is the way a function named \texttt{init\_MPO700\_Robot} is documented with doxygen:
\begin{itemize}
\item the \texttt{@brief} property gives a quick description of the function utility.
\item the \texttt{@param} property documents each argument of the function.
\item the \texttt{@retuen} property documents the return valeu of the function.
\end{itemize}

For a more detailed explanation, readers should refer to the doxygen tool tutorials that can be found online. 

\subsubsection{Adding some content by modifying Doxygen configuration file}
\label{sec:apiCMakeDoxyfile}

When developers have documented their header files, they have to do nothing more to get a standard html or pdf document. If they want to customize these documents, they have to:
\begin{itemize}
\item add some content in the \textbf{doc} sub-folder of the package's \textbf{share} folder. For instance a set of images can be put in a \textbf{img} sub-folder of the \textbf{doc} folder. 
\item modify the doxygen configuration file ("Doxyfile.in") that can be found in the \textbf{doxygen} sub-folder of the package's \textbf{share} folder. This file is used by doxygen to know how to generate the documentation. For instance, one can modify the IMAGE\_PATH contained in this file so that it points to the new \textbf{img} folder.
\item Then images can be referenced directly into doxygen headers comments using a specific keyword (@image).
\end{itemize}

Configuring doxygen behaviour is far beyond the scope of this document, interested readers may refer to online documentation and tutorials on the doxygen tooling. The only thing that is absolutely require is to let some variables of the "Doxyfile.in" unchanged: all variables whose value is \textbf{surrounded by the @ symbol must be let unchanged}. These variables are automatically fill by PID cmake scripts, for instance:
\begin{verbatim}
...
# The PROJECT_NAME tag is a single word 
PROJECT_NAME           = "@DOXYFILE_PROJECT_NAME@"

# The PROJECT_NUMBER tag can be used to enter a version. 
PROJECT_NUMBER         = "@DOXYFILE_PROJECT_VERSION@"

# The OUTPUT_DIRECTORY tag is used to specify the (relative or 
# absolute) base path where the generated documentation will 
# be put. 
OUTPUT_DIRECTORY       = "@DOXYFILE_OUTPUT_DIR@"
...
# If the GENERATE_HTML tag is set to YES (the default) Doxygen 
# will generate HTML output.
GENERATE_HTML          = @DOXYFILE_GENERATE_HTML@

# The HTML_OUTPUT tag is used to specify where the HTML docs 
# will be put. 
HTML_OUTPUT            = "@DOXYFILE_HTML_DIR@"
\end{verbatim}

When the doxygen configuration in generated by cmake, this later use the Doxyfile.in pattern file and automatically fills all fields surrounded by the @ symbol in "Doxyfile.in" according to corresponding cmake variables. Modifying these field would provoke bad behaviours.

\subsection{Configuring the package}
\label{sec:rootCMakeConfig}

TODO

\subsection{Installation of the package}
\label{sec:rootCMakeInstall}

TODO 
Dire qu'en gros il n'y a pas grand chose à faire.

INSTALL 

The shared and static version of each library will be installed in the adequate folder according to the system requirements. And the folder containing headers of the library will be installed in the include folder of the package framework version.

In CMakeFile.txt of the \texttt{apps} folder:
\begin{verbatim}
# first application to install
INSTALL(TARGETS <exe name>
  RUNTIME DESTINATION ${INSTALL_BIN_PATH}/${INSTALL_PATH_SUFFIX}
)
# second application to install : an example
if(<package>_WITH_EXAMPLES)
INSTALL(TARGETS <example name>
  RUNTIME DESTINATION ${INSTALL_BIN_PATH}/${INSTALL_PATH_SUFFIX}
)
endif(<package>_WITH_EXAMPLES)
...
\end{verbatim}
Same as for libraries applications will be installed in the bin folder of the package's framework version. If example executables have been built they will also be installed.


In CMakeFile.txt of the \texttt{test} folder:
\begin{verbatim}
if(<package>_WITH_TESTS)
INSTALL(TARGETS <test1 name> <test2 name>
  RUNTIME DESTINATION ${INSTALL_TESTS_PATH}/${INSTALL_PATH_SUFFIX}
)
endif(<package>_WITH_TESTS)
\end{verbatim}
Tests will be installed only if they have been built.

In CMakeFile.txt of the \texttt{share} folder:
\begin{verbatim}
if(CMAKE_BUILD_TYPE MATCHES Release)
install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/doc 
DESTINATION ${INSTALL_SHARE_PATH}/doc)
# other documents to install
install(FILE <path to document to install> <path to document to install>
DESTINATION ${INSTALL_SHARE_PATH})
endif(CMAKE_BUILD_TYPE MATCHES Release)
\end{verbatim}

\textbf{share} and \textbf{config} folders of the package framework version will receive files. Since these files are the same for debug and release version they will be installed only once, when installing release version.

In CMakeFile.txt of the root folder of the package:
\begin{verbatim}
if(CMAKE_BUILD_TYPE MATCHES Release)
# mandatory files to install
install(FILE license.txt package.manifest
DESTINATION ${INSTALL_CONFIG_PATH})
\end{verbatim}
Simply copying global files to the package framework version.

\pagebreak

\section{Good practices}

\subsection{C/C++ source code writing conventions}

This section explains good practices and guidelines for using packages.

\subsection{Package development convention}

The names of packages are in ascii, lower case, without space or numbers but can include '-' for separating names in compound names.

The names of packages \textbf{must be unique} considering all developed packages in the frame of the laboratory.

ICI ajouter tout ce qui concerne le nommage des composants définis dans les packages.

\subsection{Delivery}

Packages should be delivered to third parties preferably in binary form, using an OS installer. By delivered we mean:
\begin{itemize}
\item an OS installer for the package is created via CMake/CPack process presented before.
\item the installer is put on a ftp server.
\item the ftp address where to find the installer is referenced is the package.manifest file of the package.
\item the package is updated together with the workspace, so that anyone can know the existence of the installer.
\end{itemize}

The reference installer mechanism is debian packages because ubuntu/debian is the reference OS and debian packaging system is far most powerful, considering dependencies management, than basic archive based packaging. Each time a package is delivered in binary form, a corresponding debian package should be provided, unless impossible (e.g. package is specific to Windows OS).

Each time a new package version is available (tagged in master branch) at least one OS installer (preferably debian package) for that version should be provided.

The policy to reference OS installers in the package.manifest file is the following:
\begin{itemize}
\item each time an installer for a new major or minor version of the package is available, it must be added to the package.manifest file.
\item each time an installer for a new patch version of the package is available, it must replace the previous patch version for the same minor version.
\end{itemize}

\subsection{Dependencies management}

Dependencies are requirements to other software (libraries and applications) that must be installed in the system. These dependencies are defined in the CMakeFile.txt of a package and appear in OS installers provided for that package if they are used at load time or runtime. 

For the sack of simplicity for the user, each dependency should preferably be satisfied by installing the corresponding software \textbf{using an OS installer} provided by developers of this software. To easily manage indirect system dependencies, the best choice is to use sophisticated installer system, like debian packaging system when working on Linux.

Managing dependencies should be done while keeping following guideline in mind:
\begin{itemize}
\item The number of direct external dependencies should be very limited for a given package (0 to 5 max).
\item each \textbf{package dependency} in CMakeFile.txt must be satisfied by exactly one OS installer, if used at load time or runtime (for a given OS install system, by default debian).
\item each \textbf{required system dependency} in CMakeFile.txt must be satisfied by exactly one OS installer, if used at load time or runtime (for a given OS install system, by default debian).
\item each \textbf{optional system dependency} in CMakeFile.txt may be satisfied by exactly one OS installer (for a given OS install system, by default debian), if used at load time or runtime. The best option is to avoid using an optional dependency if there is no impact on performance of the software.
\item each \textbf{alternative system dependency} in CMakeFile.txt must be satisfied by exactly one OS installer (for a given OS install system, by default debian). This requires the developers/administrator of the package to choose the best alternative, which requires a compromise between several concerns:
\begin{itemize}
\item efficiency of the binary code. 
\item availability of the OS installer for the dependency. The optimal option is to choose a dependency that is satisfied by default by the target system. A less good option is too choose a dependency whose OS installer is provided. A bad option is to choose a system dependency for which no OS installer is provided.
\item re-usability of the dependency. It is always a better choice to use a commonly used dependency (e.g. boost) that can be reused across multiple packages, than a very specific dependency.
\end{itemize}
\end{itemize}


\subsection{Structuring}

The basic guideline is to separate software into many packages that are structured according to a strict "depends" hierarchy as described in figure~\ref{fig-pack-hier}. The "depends" relationship simply describes that a package depends on one or more other packages, it practically means that a package requires another package to be installed on the system either for load time, runtime or build time reason. 

Most of time, as developers commonly use shared libraries for linking their libraries or executables these dependencies are load time dependencies and so also appear in OS installer of the package. Nevertheless for optimization or other specific reasons, sometimes the "depends" relationship can be only a build-time dependency. These consideration are completely bound to build process and is not the subject of this section which focuses on the usage of package to structure development projects: the "depends" relationship has to be understood as a "functional" requirement.
\linebreak

\begin{figure}
\center
\includegraphics[scale=1]{images/package_hierarchy.png}
\caption{An example hierarchy of packages}
\label{fig-pack-hier}
\end{figure}

From a functional point of view a dependency can generally represent one of these two alternatives relationship:
\begin{itemize}
\item an "extension" relation : a child package \textbf{extends} a base package if it provides some functionalities that specialize/extends those of the base package. This is a typical relationship when a library extends the class hierarchy provided by a library of the parent package, or/and when a more specialized/complete version of an application/component is provided.
\item a "use" relation : a child package \textbf{uses} a base package if it provides new functionalities built onto those provided by the base package. This is the case when new libraries are using more basic ones or when new applications/component are built using existing applications/components.
\end{itemize}


\paragraph{Packages Dependencies guideline:}
\begin{itemize}
\item If a package has some dependencies induced by lower levels of the class hierarchy, prefer making a package for the higher level with less dependencies, and one or more dependent "extension" packages for the lower levels, each of them with the strict minimum required dependencies.
\item Prefer an atomic structuring of package by limiting the number of software artefacts generated by a package. Typical use is one package per application or per library (this advice does not targets test cases and examples).
\item When developing a component for a given middleware (ROS, OROCOS, etc.) always put the functional code (library) in one package and extend this package each time a component is built from this code.
\item Cyclic dependencies are forbidden.
\item Dependencies to multiple packages are allowed but the developer should keep in mind to have the lowest possible number of dependencies for a given package.
\item Making several packages dependent from a same package is encouraged when these dependencies put in place an "extension" relationship.
\item Limit the number of hierarchical level to the strict necessary. As a global guideline we discourage having more than 4 hierarchical levels for the "extension" relationship to keep the extension hierarchy understandable. 
\end{itemize}

\pagebreak

\part*{Conclusion}

Concerning package development, developers have to refer to dedicated document explaining coding rules and general code development guidelines.

\pagebreak

\part*{Appendix}

\section{PID cmake functions API}
\label{sec:PIDCMakefunctionsAPI}


\section{Examples}
\label{sec:Examples}





\pagebreak

\part*{POUBELLE}




 The workspace also provides categories : each category defines a specific subject that helps classifying packages/frameworks. For instance the category sensor will reference all packages or frameworks that implement the driver of a sensor. Categories can be hierarchically refined into sub categories for instance the category camera refines the category sensors. Categories can be viewed as lists of links that target frameworks/packages. The process of classification of packages is itself coming from package description (i.e. a package specifies the categories it belongs to).
 
 
GIT TAGS
 
\paragraph{Handling tags for version numbers:}
\begin{itemize}
\item creating the version number (annotated tags):
\linebreak \texttt{git tag -a v1.2.3 -m"<small description of the version>"}
\item listing all available versions: 
\linebreak \texttt{git tag -l 'v*'}
\item showing the information of a given version: 
\linebreak \texttt{git show v<version number>}
\item getting the released version in package history: 
\linebreak \texttt{git checkout tags/v<version number>}
\end{itemize}


It is also possible to apply tags to certain moment of the package's life in order to register important dates of package state and retrieve this state at any moment in the future. We define two other tag patterns to do so : publication tags, representing software developed to do experiments in the frame of a scientific publication and demo tags used to target versions that match working technical demonstrations. Demo and publication tags relies on last released version number and had specific information:
\begin{itemize}
\item \textbf{publication tags pattern} have the shape: \linebreak \texttt{pX.Y[.Z]-<journal-or-conference>-<year>}.
\item \textbf{demo tags pattern} have the shape:
\linebreak \texttt{dX.Y[.Z]-<name of demo>-<year>}.
\end{itemize}
 
GIT BRANCHING
 
\paragraph{Handling feature branches in GIT:}
\begin{itemize}
\item Creating a feature branch:
\linebreak \texttt{git checkout -b <feature name> develop}
\item Listing available branches:
\linebreak \texttt{git branch -a}
\item Incorporating a finished feature on develop:
\linebreak \texttt{git checkout develop}
\linebreak \texttt{git merge --no-ff feature-<feature name>}
\linebreak \texttt{git branch -d  feature-<feature name>}
\linebreak \texttt{git push origin develop}
\end{itemize}


\pagebreak
\paragraph{Handling hotfixes branches in GIT:}
\begin{itemize}
\item Creating a hotfix branch:
\linebreak \texttt{git checkout -b hotfix-<patch version> master}
\item Incorporating a finished hotfix on master and develop:
\linebreak \texttt{git checkout master}
\linebreak \texttt{git merge --no-ff hotfix-<patch version>}
\linebreak \texttt{git tag -a <patch version>}
\linebreak \texttt{git push origin master}
\linebreak \texttt{git checkout develop}
\linebreak \texttt{git merge --no-ff hotfix-<patch version>}
\linebreak \texttt{git branch -d  hotfix-<patch version>}
\linebreak \texttt{git push origin develop}
\end{itemize}


COLLABORATIVE WORKING

When an administrator decides to affect a pool of developers to the development of a package:
\begin{enumerate}
\item he first \texttt{clones} the official repository of the package into a private access area on the server, that is accessible (via ssh access) only to this pool of developers. 
\linebreak \texttt{ssh <private area>}
\linebreak \texttt{git clone <address of the package official repository>}
\item Second, he creates one or more feature branches as described in previous section.
\linebreak \texttt{git checkout -b <feature name> develop}
\item Third, all developers in turn \texttt{clone} this private repository into their own work station so that they can work locally and update (\texttt{push/pull})the server version of the private repository.
\linebreak \texttt{git clone <address of the package private repository>}
\item When features development is done or aborted, the administrator deletes 
the private repository on server by simply deleting the repository's folder and removing access to the users if necessary.
\linebreak \texttt{ssh <private area>}
\linebreak \texttt{rm <package private repository folder>}
\end{enumerate}
 
\begin{itemize}
\item Creating a local version of a package repository:
\linebreak \texttt{cd <path to workspace>/packages/}
\linebreak \texttt{git clone <address of the package official repository>}
\item Registering a private repository for a given package on administrator workstation:
\linebreak \texttt{cd <path to workspace>/packages/<package>}
\linebreak \texttt{git remote add <private repository name> <private repository address>}
\item To get the state of a private repository, without merging the result with administrator's local branches:
\linebreak \texttt{git fetch <private repository name>}
\item To remove a reference to a private repository (just after/before deletion of the repository by hand):
\linebreak \texttt{git remote rm <private repository name>}
\end{itemize} 

 
The development process of a package is always initiated by administrators:
\begin{itemize}
\item because they know which packages are already available and so which one can be used or extended in the frame of a master/PHD student or postdoc job.
\item because they know who is already working on similar or complementary software.
\item because they know which kind of constraints apply to code produced in the laboratory (licenses, access restriction, etc.)
\end{itemize} 
They are so the only persons that can truly:
\begin{itemize}
\item orient and help developers to increase their productivity by reusing existing code.
\item optimize collaboration between developers.
\item centralize the whole process.
\end{itemize} 

the \textbf{categories} folder is structured according a set of topics, each topic being itself a folder that in turn contains either other subcategories or \textbf{links to frameworks}. \textbf{categories} only goal is to help finding available packages (under binary form) according to a given theme. Considering a category, packages that are relevant for the theme it defines are referenced as links (symbolic relative links in Linux) to frameworks folders.


\paragraph{Rules for the modification of the repository:}
\begin{itemize}
\item .gitignore cannot be modified.
\item No new direct subfolder or file of the workspace root can be created or removed.
\item files (package references, licenses definitions) can be added or removed only by administrators.
\end{itemize}

\subsubsection{Deployment in frameworks}

Frameworks are simple repositories in which the binary code or more generally the code usable by third parties is installed. The install process of a package  version in its framework is made either :
\begin{itemize}
\item by package developers using \texttt{make install}, after the compilation phase. The package version is then the current version
\item by package users, after downloading the archive of the package, using OS specific primitives (e.g. \texttt{dpkg -i}).
\end{itemize}
In both cases, the \textbf{CMakeList.txt} file of a given package defines the way this package is deployed (according to rules defined in this document), either:
\begin{itemize}
\item directly, by generating the \texttt{make install} procedure.
\item indirectly, using \textit{cpack} toolset, by generating the \textbf{OS installer} that does the same job, but without having to get access to the package repository.
\end{itemize}


\subsubsection{General policy to manage many package versions}

The following rules should be applied whenever developers want to install a given package version:
\begin{itemize}
\item Given a package version with given major and minor version numbers, its more recent patch version should always be used. If a new patch version becomes available (e.g. 1.4.2 after a hotfix on 1.4.1) it should replace older patch versions (e.g. 1.4.0 or 1.4.1) if any installed in the package framework. This ensures the developer to use a version with less bug or security problems.
\item When a new backward compatible version (e.g. 1.5.0) of a package is to be installed, it may replace the previous version (e.g. 1.4.2) or be simply added to the framework. Most of time it is preferable to test effective compatibility between this new version and the code that was using the old version.
\item When a new non backward compatible version of a package is to be installed (e.g. 2.0.0 while 1.4.2 is already installed), it should not immediately replace older versions. The package version is simply added to the package framework, which ensures that other packages can still work with an older version already installed.
\end{itemize}

\paragraph*{When to install ?}
Generally, there are two main case when developer want to install a package version:
\begin{itemize}
\item they want to install software artefacts (libraries, scripts, etc.) coming from a package they are currently developing, in order to use them. In this case, package version is installed in the \textbf{own} folder of the framework. This folder is updated each time they compile their package.
\item  they develop or use a package that requires other packages with version constraints. For a given required package, a released version with number contained between its min and max version constraints has to be installed. In the allowed "interval of versions", the last backward compatible version with last patch version should be installed.
\end{itemize}

\paragraph*{How to install ?}
There are basically two way to install a given package version:
\begin{itemize}
\item from package repository: the developer has to go back to the given version in history (on master branch) and install it.
\linebreak \texttt{git checkout master}
\linebreak \texttt{git checkout tags/v<version number>}
\linebreak \texttt{cd build}
\linebreak \verb|{cmake .. - DCMAKE_INSTALL_PREFIX=../../frameworks/|
\linebreak \verb|<package name>/<version number>/|
\linebreak \texttt{make}
\linebreak \texttt{make install}
\item from an OS installer: it depends on the installer used but the install prefix has to be specified quite the same way as previously.
\end{itemize}

\subsection{Referencing Packages in Workspace}

To reference available packages potentially accessible in the workspace, we use the \textbf{references} folder in which administrators put \textbf{package.manifest} files. In the workspace these files are used to tell to users which packages are available and where they can be found. When a package administrator wants to make the package available to others, he must add the corresponding \textbf{package.manifest} in the \textbf{references} folder of its workspace and commit the changes to the workspace. All users will then know the package existence whenever they update their workspace. When a package definitively become obsolete, the corresponding manifest file is removed from the \textbf{references} folder and the changes into the workspace are committed.

\paragraph{Basic commands}
\begin{itemize}
\item Referencing a package :
\linebreak copying the package.manifest file into the references folder of the workspace, and \textbf{rename it} in <name of package>.manifest (name of packages are supposed to be unique).
\linebreak \texttt{git add <package name>.manifest}
\linebreak \texttt{git commit -m "<package manifest file> is now referenced"}
\linebreak \texttt{git push origin master}
\item Updating available references (when updating the workspace):
\linebreak \texttt{git pull origin master}
\item Dereferencing a package
\linebreak \texttt{git rm <package name>.manifest}
\linebreak \texttt{git commit -m "<package manifest file> is no more referenced"}
\linebreak git push origin master
\end{itemize}

\subsection{Licensing packages}

The licensing of packages has to be done according to a general politics of the laboratory, team or sub-group. License is let free to their decision and constraints, nevertheless, as software licenses are the same for everybody, licenses definitions are shared between all people.

The \textbf{licenses} folder contains definitions for all licenses that are available for use in package description. Each license is defined in a specific file that looks like this for the GPLv3 license (file name is "GNUGPLv3.license") :
\begin{verbatim}
<license id="GPLv3" fullname="GNU General Public 
License version 3" organization="Free Software Foundation"/>
<description>
/*
* <package_name> : <package_short_description>
* Copyright (C) <year>  <authors_name>

* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
</description>
<legalterms>
//input the full legal terms of the license here
</legalterms>
</license>
\end{verbatim}


\paragraph{Data Type Definition:}
\begin{verbatim}
<!DOCTYPE license [

<!ELEMENT license (description, legalterms)>
<!ELEMENT description (CDATA)>
<!ELEMENT legalterms (CDATA)>

<!ATTLIST license id CDATA #REQUIRED>
<!ATTLIST license fullname CDATA #REQUIRED>
<!ATTLIST license organization CDATA #REQUIRED>
]>
\end{verbatim}


\paragraph{Explanations:}
\begin{itemize}
\item the \texttt{<license>} markup is the root of the XML description : it gives the short name of the license used as an identifier (\texttt{id}) in the package description as well as its complete legal name (\texttt{fullname})and the name of the \texttt{organization} that wrote it.
\item the \texttt{<description>} markup contains a short text that has to be put by developers into any file used in the package (source, interface, test, etc.). Some part have tags with "<" and ">" characters : this is where package specific informations (name, authors, short description etc.) is written by developers.
\item the \texttt{<legalterms>} markup contains the full legal text of the license. Thanks to this text a license text file can be generated and added with redistribution of packages (e.g. both in repositories and installers).
\end{itemize}

\paragraph{Important remarks:} 
\begin{itemize}
\item As a package has one license only, using different licenses requires to define different package.
\item If a package has one license at a time this license can evolve along time.
\item Only administrators can add/remove/modify license files in the workspace.
\end{itemize}


\subsection{Categorizing packages}

When developing it is often useful to know which package provide some useful things relative to one or more topics. The aim of the \textbf{categories} folder is to standardize the classification and the finding of packages relevant for given concerns.

The \textbf{categories} folder is structured into subfolders that describe known categories. Each category folder is itself structured the following way:
\begin{itemize}
\item sub folder describes sub categories. A sub category refines the topic of its containing category. For instance folders \textbf{arms} and \textbf{wheeled vehicles} are contained in the category folder \textbf{robot}. These sub categories can in turn be refined the same way.
\item symbolic links represent target packages of the category. The name of the link is simply the name of the package, the target of the link is a given package framework. The target itself is always expressed as a \textbf{relative path} from the containing category folder to the target framework. By default these links target nothing in the file system as long as the package's framework has not been installed in the \textbf{frameworks} folder.
\end{itemize}

\paragraph*{Remark:} 
a same package can be targeted by more than one link: it means that the package belongs to different (sub)categories according to the different point of view of the developers. Doing so, anyone can have his own point of view of the package depending on its center of interest.
\linebreak

To organize the development, defining some "standard categories" should help developers to classify their packages. This requires to list categories of code that is useful for robotic applications development. For instance :
\begin{itemize}
\item sensors
\begin{itemize}
\item vision
\begin{itemize}
\item cameras
\item kinects
\item lasers
\end{itemize}
\item force sensors
\item encoders
\end{itemize}
\item robots
\begin{itemize}
\item arms
\item wheeled vehicles
\item humanoids
\end{itemize}
\item simulators
\item navigation
\begin{itemize}
\item cartography
\item positioning
\end{itemize}
\item planning
\begin{itemize}
\item mission
\item path
\item trajectory
\end{itemize}
\item middleware
\begin{itemize}
\item ros
\item contract
\item orocos
\end{itemize}
\end{itemize}

Of course categories can evolve/change along time, when developers want new categories.

\subsubsection{Working with categories}

The only people that can modify \textbf{categories} folder are package administrators. Each time a new package is created, developers define which are its relevant categories and wrote them in the package.manifest file of the package. When an administrator of a package wants to reference it :
\begin{itemize}
\item he first copy/rename the package.manifest file into the \textbf{references} folder.
\item according to the relevant categories of tha package defined in the manifest, he:
\begin{itemize}
\item creates new (sub)category folders in the the \textbf{categories} folder of its workspace, if the corresponding categories do not exist.
\item creates as many symbolic links that target the package framework as there are relevant categories for the package and put these links into the adequate category folders.
\end{itemize}
\item once done he commits its workspace.
\end{itemize}

From developers point of view, categories just help finding packages that are relevant for given topics. Each time they update their workspace, all available categories and classification of packages according to categories are updated. 

To search packages, they can simply navigate in the file system of the \textbf{categories} folder. 
\begin{itemize}
\item if the package is already installed in the \textbf{frameworks} folder he can simply follow the link.
\item otherwise the link is broken, and the developer has to install the corresponding package.
\end{itemize}

\end{document}